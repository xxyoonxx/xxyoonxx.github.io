---
layout: post
title: etc10
description:
sitemap: false
hide_last_modified: true
---
# 메시지 브로커

* toc
{:toc .large-only}

![](/assets/img/etc/messagebroker.png)

쇼핑몰 서비스에서 어떤 물건을 주문했을 때, `결제`, `재고차감`, `문자 알림`이 호출된다고 가정해보자.  
보통은 서비스(혹은 파사드 등의 계층)에서 다른 도메인의 기능을 호출하는 모습을 상상할 것이다.

```
[주문 서비스]
 → 결제 서비스 호출
 → 재고 차감 서비스 호출
 → 문자 알림 서비스 호출

OrderService {
   order() {
      payService.pay();        // 결제
      stockService.reduct();   // 재고 차감
      smsService.notify();     // 문자 알림
   }
}
```

그러나 이런 동기적 직접 연결 방식은 서비스가 커질수록 몇 가지 단점이 드러나게 된다.

1. 단일 장애점: 주문 서비스에서 장애가 발생하면 모든 서비스가 동작하지 않게 된다.
2. 높은 결합도: 유지보수성과 독립성이 떨어진다.
3. 확장성 낮음: 새로운 서비스가 추가되면 기존 서비스 코드에 직접 호출 로직을 추가해야하므로 코드가 점점 복잡해진다.
4. 복구 어려움: 중간에 한 단계라도 실패 시 예외나 복구 처리가 복잡해진다.

이런 단점을 해결하기 위해 사용하는 것이 **메시지 브로커**이다.  
메시지 브로커는 서비스 간 직접 호출 대신 이벤트를 `메시지` 형태로 각 서비스에 전달해주는 중간 매개체 역할을 한다.  

```
[주문 서비스]
 → 메시지 브로커에 "주문됨" 이벤트 발행

[결제 서비스] ← 메시지 브로커에서 이벤트 수신 후 결제
[재고 서비스] ← 메시지 브로커에서 이벤트 수신 후 재고 차감
[알림 서비스] ← 메시지 브로커에서 이벤트 수신 후 문자 발송
```

# 구조

```
Producer → [ Broker (Queue or Topic) ] → Consumer
```

### 생산자 Producer
- 메시지를 보내는 쪽  
예) 주문 완료 시 이벤트를 발생시키는 주문 서비스

### Queue/Topic
- 메시지가 임시로 저장되는 공간
- Queue: 1:1 구조로 하나의 메시지를 하나의 소비자가 수신한다.
![](https://tsh.io/wp-content/uploads/2021/04/message-broker-example-1_.png)
- Topic: Pub/Sub구조로 하나의 메시지를 여러 소비자가 수신한다. 
![](https://tsh.io/wp-content/uploads/2021/04/message-broker-example-2_.png)

### 소비자 Consumer
- 메시지를 받아서 처리하는 쪽  
예) 결제, 재고, 알림 서비스

### 구독 Subscription
- 소비자(Consumer)가 메시지 브로커에 특정 주제(Topic)의 메시지를 받고 싶다고 등록하는 것
- 생산자는 소비자에 대한 정보 없이 단순히 메시지만 발행하고, 브로커는 이를 소비자에게 전달

# 장점

1. 느슨한 결합: 서비스 간 직접적 의존 관계가 제거 된다.
2. 장애 격리: 한 서비스에 장애가 발생해도 메시지가 메시지 브로커에 저장되어있기 때문에 전체 시스템에 영향을 주지 않는다.
3. 신뢰성 보장: 실패한 서비스도 나중에 메시지를 다시 꺼내 처리할 수 있다.
4. 성능 향상: 비동기 처리를 지원하기 때문에 다른 서비스의 작업이 끝나는 것을 기다릴 필요 없이 요청을 빠르게 마무리 할 수 있다.

# 단점

1. 복잡한 구조: 메시지 발행/구독, 큐/토픽, 에러 처리 등을 따로 관리해야 하므로 구조가 복잡해진다.
2. 운영 부담: 브로커도 하나의 서버로 관리해야 하므로 자원 부담이 늘어나게 된다.
3. 디버깅 어려움: 호출 흐름이 명확하지 않으므로 메시지에 대한 추적이 따로 필요하다.

# 사용 예시

일반적으로 `작업이 오래 걸리거나`, `여러 서비스가 동일 이벤트에 반응하거나`, `재시도나 장애 복구가 중요`한 작업에 사용하면 유용하다. 순차적으로 처리해야 하는 비즈니스 정합성이 필요한 작업에는 순서 보장이 되지 않으므로 도입을 추천하지 않는다.

-  **MSA(마이크로서비스 아키텍처) 환경**  
서비스가 여러 개로 분리되어 있고, 각 서비스가 특정 이벤트에 독립적으로 반응해야 할 때 유용하다.

- **모바일 앱의 알림 기능**  
메시지 브로커를 통해 알림 메시지를 비동기 전송하면 메인 로직이 지연되지 않음

- **이메일 또는 SMS 발송**  
일반적으로 외부 API를 거치기 때문에 느려질 수 있으나 메시지로 처리하면 성능 향상

- **배치 처리나 백그라운드 작업**  
파일 변환, PDF 생성 등 시간이 오래 걸리는 작업을 사용자가 기다리지 않도록 메시지로 분리해서 비동기 처리

- **트래픽 폭주 방어 (버퍼 역할)**  
이벤트, 프로모션 등으로 순간적으로 요청이 몰릴 때 메시지를 큐에 쌓아두고 순차적으로 처리하면 시스템이 안정됨