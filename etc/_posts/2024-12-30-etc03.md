---
layout: post
title: etc03
sitemap: false
hide_last_modified: true
---
# 트랜잭션 격리수준

* toc
{:toc .large-only}

# 트랜잭션 격리수준이란?
트랜잭션 격리수준이란 여러 트랜잭션이 실행 될 때, 한 트랜잭션에 다른 트랜잭션이 얼마나 간섭할 수 있는지를 설정하는 옵션이다.  

## 여러 트랜잭션은 언제 발생하는가?
트랜잭션이 여러 개라는건 데이터에서 발생하는 `동시성 문제`라고 생각하면 된다.
1. DB에서 여러 클라이언트가 동시에 작업을 수행 할 때
  - 여러 사용자가 웹 애플리케이션에서 동시에 `조회` 등의 기능을 요청
2. 하나의 애플리케이션이 병렬로 여러 작업을 처리 할 때
  - 여러 스레드나 비동기 작업으로 데이터베이스에 동시에 접근

이 상황에서 트랜잭션 격리를 제대로 하지 못하면 트랜잭션 이상이 발생한다.

---

## 주요 트랜잭션 이상
1. Dirty Read
  - 다른 트랜잭션이 커밋하지 않은 데이터를 읽음
  - A 트랜잭션이 데이터를 변경 후 커밋하지 않았는데, B 트랜잭션이 이를 조회
2. Non-Repeatable Read
  - 같은 트랜잭션에서 같은 데이터를 읽을 때 값이 달라짐
  - A 트랜잭션이 하나의 데이터 조회 > B 트랜잭션이 이를 `수정/삭제` 후 커밋 > A 트랜잭션이 데이터 재조회 시 값이 바뀌어 있음
3. Phantom Read
  - 같은 쿼리 실행 시 결과가 다름
  - A 트랜잭션이 여러 데이터 조회 > B 트랜잭션이 새로운 데이터 `삽입/삭제` > A 트랜잭션이 데이터 재조회 시 다른 결과가 나타남
  - 기존 조회 조건에 속해 있지 않던 데이터들이 생기거나, 속해있던 데이터들이 삭제되는 것

`Non-Repeatable Read`와 `Phantom Read`는 얼핏보면 비슷해보일 수 있는 개념이나 각각 차이가 있다.  

### Non-Repeatable Read
우선, `Non-Repeatable Read`는 `단일 행이 변경`되는 것이 관건이다.
Non-Repeatable Read이라는 단어 그대로 Repeat을 했는데 되지 않았다는 뜻이다.
`데이터를 단일 행 조회했다 && 데이터가 수정/삭제 되었다`라면 Non-Repeatable Read이다.

```
1. A 트랜잭션이 id=1인 행의 name="John"을 읽음.
2. B 트랜잭션이 id=1의 name 값을 "Doe"로 수정하고 커밋.
3. A 트랜잭션이 다시 id=1을 읽으면 name="Doe"로 값이 바뀌어 있음.

동일한 행에 다른 값이 나옴
```

### Phantom Read
`Phantom Read`는 `조회한 데이터 집합이 바뀌는 것`이 관건이다
`데이터에 조건을 걸어 여러 건 조회한다 && 데이터 수가 달라졌다`
이로 인해 집합의 크기가 달라졌다면 Phantom read이다.

```
1. A 트랜잭션이 salary > 5000 조건으로 직원 목록을 조회(결과: 3명).
2. B 트랜잭션이 새로운 직원을 salary=6000으로 추가하고 커밋.
3. A 트랜잭션이 동일한 조건으로 다시 조회하면 결과에 새로운 직원이 포함되어 있음 (결과: 4명).

다수의 데이터 조회 결과가 달라짐
```

---

이러한 트랜잭션 이상을 방지하기 위해서는 트랜잭션 격리수준을 적절히 선택해야한다.
격리수준이 낮아질수록 성능이 좋아지지만 데이터 간섭 문제가 발생할 가능성이 높아지며,  
데이터를 건드리지 않는 읽기 위주의 `대규모 조회`의 경우 낮은 격리 수준이 사용자 경험을 더 높여 줄 수 있다.
반대로 격리수준이 높아질수록 성능이 저하되지만 그만큼 데이터 무결성과 일관성을 더 잘 보장해준다.

| **격리수준**         | **Dirty Read** | **Non-Repeatable Read** | **Phantom Read** | **특징**                                                                 |**적용**|
|:----------------------:|:----------------:|:-------------------------:|:------------------:|---------------------------------------------------------------------------|
| **Read Uncommitted** | 발생 가능       | 발생 가능                | 발생 가능         | 가장 낮은 격리 수준. 트랜잭션 수행 중 데이터가 즉시 노출되며 성능은 가장 높음. |실시간 모니터링|
| **Read Committed**   | 방지            | 발생 가능                | 발생 가능         | 커밋된 데이터만 읽을 수 있음. 최신 커밋값을 사용함 대부분 DBMS의 기본 설정(MySQL 제외).            |실시간 재고 확인|
| **Repeatable Read**  | 방지            | 방지                     | 발생 가능         | 동일 트랜잭션 내에서 읽은 조회 데이터를 유지.             | 결제 시의 장바구니 금액. 계좌이체 진행 중의 잔액|
| **Serializable**     | 방지            | 방지                     | 방지              | 가장 높은 격리 수준. 트랜잭션이 순차적으로 실행되는 것처럼 보임.             |동시 계좌이체 방지|

## 트랜잭션 격리수준 설정
DB마다 격리수준의 기본값과 설정방법이 각기 다르다.

### Oracle
- 디폴트: `Read Committed`
- 현재 세션만 설정 가능하며 전역 세션이나 특정 트랜잭션에는 설정이 불가능하다.

```SQL
ALTER SESSION SET ISOLATION_LEVEL READ COMMITTED;
```

### MySQL
- 디폴트: `Repeatable Read`
- 현재 세션 및 전역 세션, 하나의 특정 트랜잭션에서도 설정 가능하다.
  - 특정 트랜잭션에 설정할 경우, 트랜잭션 시작 전에만 설정 가능하며 해당 트랜잭션 종료 시 현재 세션 격리 수준으로 돌아간다.

```SQL
-- 1. 글로벌 설정 (모든 세션에 적용)
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 2. 세션별 설정 (현재 세션에만 적용)
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 3. 특정 트랜잭션에서 설정
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```